<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Depot Live Dashboard</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css"/>
<style>
  body { font-family: system-ui, Arial, sans-serif; margin:0; }
  header { padding: 12px 16px; border-bottom: 1px solid #e5e5e5; }
  h1 { font-size: 18px; margin: 0; }
  main { padding: 16px; max-width: 1200px; margin: 0 auto; }
  .grid { display: grid; gap: 12px; grid-template-columns: repeat(auto-fill,minmax(240px,1fr)); }
  .card { border: 1px solid #e5e5e5; border-radius: 8px; padding: 12px; }
  .card h3 { margin: 0 0 8px 0; font-size: 16px; }
  .truck { display: flex; justify-content: space-between; padding: 6px 0; border-top: 1px dashed #eee; font-weight: 600; }
  .truck:first-of-type { border-top: 0; }
  .ok { color: #257a3e; }
  .warn { color: #b00020; }
  #map { height: 420px; margin-top: 16px; border-radius: 8px; border: 1px solid #e5e5e5; }
  .small { color:#666; font-size:12px; }
</style>
</head>
<body>
<header>
  <h1>Depot Live Dashboard</h1>
</header>
<main>
  <div class="small" id="status">Loading…</div>
  <div class="grid" id="sections"></div>
  <div id="map"></div>
</main>

<script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
<script>
/* ==================== CONFIG ==================== */
const API_BASE = "https://api.eu.navixy.com/v2"; // <-- change to your region
const REFRESH_MS = 30000;            // auto-refresh interval
const DWELL_THRESHOLD_MIN = 30;      // red if dwell exceeds this
const LOOKBACK_HOURS = 48;           // how far back to read events

/* ==================== HELPERS ==================== */
const qs = new URLSearchParams(location.search);
const HASH = qs.get("session_key"); // Navixy app will append ?session_key=...
if (!HASH) console.warn("No session_key in URL. Enable Session key in User app.");

// Use recommended Authorization header: "NVX <hash>"  (API key or session hash)
function apiPost(path, body) {
  return fetch(`${API_BASE}${path}`, {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      "Authorization": `NVX ${HASH}`
    },
    body: JSON.stringify(body || {})
  }).then(r => r.json());
}

/* ==================== DATA LOADERS ==================== */
// 1) Trackers (IDs + labels)
async function getTrackers() {
  // /tracker/list returns trackers available to current user
  const res = await apiPost("/tracker/list", {});
  if (!res.success) throw new Error("tracker/list failed");
  // Normalize to {id, label}
  return res.list.map(t => ({ id: t.id, label: t.label || t.name || `#${t.id}` }));
}

// 2) Last positions for map (use /tracker/get_states with list of IDs)
async function getStates(trackerIds) {
  if (!trackerIds.length) return {};
  const res = await apiPost("/tracker/get_states", { trackers: trackerIds });
  if (!res.success) throw new Error("tracker/get_states failed");
  // returns { states: { [tracker_id]: { gps: {location:{lat,lng}, updated:...}, ... } } }
  return res.states || {};
}

// 3) Geofence enter/exit events for dwell computation
async function getGeofenceEvents() {
  const to = new Date();
  const from = new Date(to.getTime() - LOOKBACK_HOURS * 3600 * 1000);
  const fmt = d => d.toISOString().slice(0,19).replace('T',' '); // "yyyy-MM-dd HH:mm:ss"

  const res = await apiPost("/history/user/list", {
    from: fmt(from),
    to: fmt(to),
    events: ["inzone","outzone"], // geofence enter/exit
    limit: 1000,
    ascending: true
  });
  if (!res.success) throw new Error("history/user/list failed");
  // Each entry has fields like: event: "inzone"|"outzone", tracker_id, time, extra.zone_ids, extra.zone_labels
  return res.list || [];
}

/* ==================== DWELL CALC ==================== */
// Build live dwelling map: { zoneLabel: [ {trackerId, trackerLabel, since, minutes} ] }
function computeLiveDwell(events) {
  // Sort just in case
  events.sort((a,b) => new Date(a.time) - new Date(b.time));
  const inside = {}; // inside[tracker_id][zoneId] = { since: Date, zoneLabel }
  const zones = {};  // zones[zoneLabel] = [ {trackerId, trackerLabel, since, minutes} ]

  for (const e of events) {
    const tid = e.tracker_id;
    const when = new Date(e.time);
    const zoneId = (e.extra && e.extra.zone_ids && e.extra.zone_ids[0]) || null;
    const zoneLabel = (e.extra && e.extra.zone_labels && e.extra.zone_labels[0]) || "Unknown zone";
    if (!zoneId) continue;

    inside[tid] = inside[tid] || {};

    if (e.event === "inzone") {
      // mark entry if not already inside
      if (!inside[tid][zoneId]) inside[tid][zoneId] = { since: when, zoneLabel };
    } else if (e.event === "outzone") {
      // clear if inside
      if (inside[tid][zoneId]) delete inside[tid][zoneId];
    }
  }

  // Convert current "inside" map to zone -> list of trucks with minutes
  const now = new Date();
  for (const tid of Object.keys(inside)) {
    for (const zid of Object.keys(inside[tid])) {
      const entry = inside[tid][zid];
      const minutes = Math.max(0, Math.round((now - entry.since) / 60000));
      zones[entry.zoneLabel] = zones[entry.zoneLabel] || [];
      zones[entry.zoneLabel].push({ trackerId: Number(tid), since: entry.since, minutes });
    }
  }
  return zones;
}

/* ==================== RENDERING ==================== */
function renderSections(zones, trackerLookup) {
  const container = document.getElementById("sections");
  container.innerHTML = "";

  const zoneNames = Object.keys(zones).sort();
  if (!zoneNames.length) {
    container.innerHTML = '<div class="card"><h3>No trucks inside depot zones</h3><div class="small">Waiting for geofence events…</div></div>';
    return;
  }

  for (const name of zoneNames) {
    const list = zones[name].sort((a,b) => b.minutes - a.minutes);
    const card = document.createElement("div");
    card.className = "card";
    const h = document.createElement("h3");
    h.textContent = `${name} (${list.length})`;
    card.appendChild(h);

    for (const t of list) {
      const label = (trackerLookup[t.trackerId] && trackerLookup[t.trackerId].label) || `#${t.trackerId}`;
      const p = document.createElement("div");
      p.className = "truck " + (t.minutes > DWELL_THRESHOLD_MIN ? "warn" : "ok");
      const mins = `${t.minutes} min`;
      p.innerHTML = `<span>${label}</span><span>${mins}</span>`;
      card.appendChild(p);
    }
    container.appendChild(card);
  }
}

let map, markers = [];
function renderMap(states, trackerLookup) {
  const mDiv = document.getElementById("map");
  if (!map) {
    map = L.map(mDiv).setView([0,0], 2);
    L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", { maxZoom: 19 }).addTo(map);
  }
  // clear
  markers.forEach(m => map.removeLayer(m));
  markers = [];

  const bounds = [];
  for (const tid of Object.keys(states)) {
    const st = states[tid];
    const gps = st && st.gps;
    const loc = gps && gps.location;
    if (!loc) continue;
    const label = (trackerLookup[tid] && trackerLookup[tid].label) || `#${tid}`;
    const marker = L.marker([loc.lat, loc.lng]).addTo(map).bindPopup(label);
    markers.push(marker);
    bounds.push([loc.lat, loc.lng]);
  }
  if (bounds.length) map.fitBounds(bounds, { padding: [30,30] });
}

async function update() {
  const status = document.getElementById("status");
  try {
    status.textContent = "Updating…";
    const trackers = await getTrackers();
    const trackerLookup = Object.fromEntries(trackers.map(t => [t.id, t]));
    const events = await getGeofenceEvents();
    const zones = computeLiveDwell(events);
    renderSections(zones, trackerLookup);

    const states = await getStates(trackers.map(t => t.id));
    renderMap(states, trackerLookup);
    status.textContent = `Updated at ${new Date().toLocaleTimeString()}`;
  } catch (err) {
    console.error(err);
    status.textContent = "Error loading data. Check console.";
  }
}

// kick off + auto-refresh
update();
setInterval(update, REFRESH_MS);
</script>
</body>
</html>
